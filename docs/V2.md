# kFSM v2 - A Redesigned State Machine Framework

## Overview

kFSM v2 is a redesign of the state machine framework that prioritizes **pure decision logic**, **reliable effect execution**, and **testability**. It introduces a clear separation between deciding what should happen (pure) and executing side effects (impure), making it ideal for distributed systems that require reliable state transitions.

## Why v2?

### Problems with v1

While v1 was functional and served well for simple use cases, several pain points emerged when building complex, distributed workflows:

#### 1. Effects Mixed with Transitions

In v1, transitions execute their effects inline:

```kotlin
// v1: Effects are executed during the transition
class SendEmail(from: OrderState, to: OrderState) : OrderTransition(from, to) {
    override fun effect(value: Order): Result<Order> {
        // This runs immediately during the transition!
        emailService.send(value.customerEmail, "Order confirmed")
        return Result.success(value)
    }
}
```

**Problem**: If the database commit fails after the effect runs, the email is sent but the state isn't persisted. You get inconsistent state.

#### 2. Complex Hook System

v1 requires a `Transitioner` with `preHook`, `postHook`, `persist`, and `persistWithOutbox` methods:

```kotlin
// v1: Complex transitioner with multiple hooks
class OrderTransitioner : Transitioner<String, OrderTransition, Order, OrderState>() {
    override fun preHook(value: Order, via: OrderTransition): Result<Unit> { ... }
    override fun persist(from: OrderState, value: Order, via: OrderTransition): Result<Order> { ... }
    override fun postHook(from: OrderState, value: Order, via: OrderTransition): Result<Unit> { ... }
}
```

**Problem**: Business logic gets scattered across transitions and transitioner hooks. Testing requires mocking the transitioner.

#### 3. DeferrableEffect is Bolted On

The transactional outbox pattern in v1 was added as an optional feature via `DeferrableEffect`:

```kotlin
// v1: Outbox pattern requires implementing a separate interface
class SendEmail(...) : OrderTransition(...), DeferrableEffect<String, Order, OrderState> {
    override fun serialize(value: Order): Result<EffectPayload> { ... }
    override val effectType = "send_email"
}
```

**Problem**: The serialization and execution logic are separate, making it hard to ensure consistency. Not all transitions use the pattern, leading to mixed approaches.

#### 4. State Type Parameters are Verbose

v1 states carry all type parameters:

```kotlin
// v1: Every state needs ID, V, S type parameters
sealed class OrderState : State<String, Order, OrderState>(...)
```

**Problem**: The `ID` and `V` type parameters rarely add value at the state level and create boilerplate.

#### 5. Testing Requires Infrastructure

Testing v1 transitions requires setting up a transitioner and often mocking persistence:

```kotlin
// v1: Testing requires transitioner setup
@Test
fun `confirm order sends email`() {
    val transitioner = TestTransitioner()
    val result = transitioner.transition(order, ConfirmOrder())
    // How do we verify the email was sent?
}
```

**Problem**: You can't easily test the decision logic in isolation from the effect execution.

---

## v2 Design Philosophy

### Core Principle: Pure Decisions, Deferred Effects

v2 separates **deciding** what should happen from **executing** side effects:

1. **Transitions** contain pure `decide()` functions that return a `Decision`
2. **Decisions** describe the new state and effects to emit
3. **Effects** are stored in a transactional outbox during the state change
4. **EffectProcessor** executes effects later, ensuring reliable delivery

```kotlin
// v2: Pure decision logic
class ConfirmOrder(private val paymentId: String) : OrderTransition(
    from = OrderState.Pending,
    to = OrderState.Confirmed
) {
    override fun decide(value: Order): Decision<OrderState, OrderEffect> =
        Decision.accept(
            state = OrderState.Confirmed,
            effects = listOf(
                OrderEffect.SendConfirmationEmail(value.id, value.customerEmail),
                OrderEffect.NotifyWarehouse(value.id)
            )
        )
}
```

---

## v1 vs v2 Comparison

| Aspect | v1 | v2 |
|--------|----|----|
| **Effect execution** | Inline during transition | Deferred via outbox |
| **Transitioner** | Required with hooks | Simple `StateMachine` class |
| **Effect definition** | `effect()` method on Transition | Sealed class of Effect types |
| **Outbox pattern** | Optional via DeferrableEffect | Built-in, always used |
| **State type params** | `State<ID, V, S>` | `State<S>` |
| **Testing** | Requires mocking | Pure functions, easy to test |
| **Multi-step workflows** | Manual coordination | EffectProcessor chains automatically |
| **Async waiting** | Not supported | AwaitableStateMachine |

### Type Signature Comparison

```kotlin
// v1 State
sealed class OrderState : State<String, Order, OrderState>(transitionsFn = { ... })

// v2 State  
sealed class OrderState : State<OrderState>() {
    override fun transitions() = ...
}
```

```kotlin
// v1 Transition
class ConfirmOrder : Transition<String, Order, OrderState>(from, to) {
    override fun effect(value: Order): Result<Order> = ...
}

// v2 Transition
class ConfirmOrder : Transition<String, Order, OrderState, OrderEffect>(from, to) {
    override fun decide(value: Order): Decision<OrderState, OrderEffect> = ...
}
```

### Architecture Comparison

**v1 Architecture:**
```
Transitioner.preHook() → Transition.effect() → Transitioner.persist() → Transitioner.postHook()
                              │                        │
                              └── Side effects ←───────┘ (mixed concerns)
```

**v2 Architecture:**
```
Transition.decide() → StateMachine.transition() → Repository.saveWithOutbox()
        │                       │                         │
        │                       │                         ▼
   Pure function          Validates &            Atomic save of state
   (no side effects)      applies decision       + outbox messages
                                                         │
                                                         ▼
                          EffectProcessor.processAll() ──┘
                                   │
                                   ▼
                          EffectHandler.handle() → May trigger more transitions
```

---

## Key v2 Components

### Decision

A sealed class representing the outcome of a transition:

```kotlin
sealed class Decision<S : State<S>, E : Effect> {
    data class Accept<S, E>(val state: S, val effects: List<E>) : Decision<S, E>()
    data class Reject<S, E>(val reason: String) : Decision<S, E>()
}
```

### Effect

A sealed class defining all possible side effects:

```kotlin
sealed class OrderEffect : Effect {
    data class SendEmail(val orderId: String, val email: String) : OrderEffect()
    data class ChargePayment(val orderId: String, val amount: Money) : OrderEffect()
    data class NotifyWarehouse(val orderId: String) : OrderEffect()
}
```

### EffectHandler

Executes effects and returns outcomes that may trigger further transitions:

```kotlin
class OrderEffectHandler : EffectHandler<String, Order, OrderState, OrderEffect> {
    override fun handle(valueId: String, effect: OrderEffect): Result<EffectOutcome<...>> =
        when (effect) {
            is OrderEffect.SendEmail -> {
                emailService.send(effect.email, "Order confirmed")
                Result.success(EffectOutcome.Completed)
            }
            is OrderEffect.ChargePayment -> {
                val result = paymentService.charge(effect.amount)
                Result.success(EffectOutcome.TransitionProduced(
                    valueId,
                    PaymentCompleted(result.transactionId)
                ))
            }
        }
}
```

### EffectProcessor

Polls the outbox and executes effects:

```kotlin
val processor = EffectProcessor(
    outbox = outbox,
    handler = effectHandler,
    stateMachine = stateMachine,
    valueLoader = { id -> repository.findById(id) }
)

// Run periodically or triggered by database notifications
processor.processAll()
```

### AwaitableStateMachine

For synchronous-feeling workflows that span multiple async effects:

```kotlin
val awaitable = AwaitableStateMachine(
    stateMachine = stateMachine,
    pendingRequestStore = pendingRequestStore,
    isTerminalState = { state ->
        state is OrderState.Delivered || state is OrderState.Cancelled
    }
)

// Suspends until terminal state is reached
val finalOrder = awaitable.transitionAndAwait(
    value = order,
    transition = ConfirmOrder(paymentId),
    timeout = 30.seconds
)
```

---

## Background Processing in Production

The `EffectProcessor` needs to be triggered to execute pending effects from the outbox. In production with a cloud MySQL database, there are several approaches with different trade-offs:

### 1. Polling (Simplest)

A background thread or scheduled job periodically calls `processAll()`:

```kotlin
// Using a ScheduledExecutorService
val scheduler = Executors.newSingleThreadScheduledExecutor()
scheduler.scheduleAtFixedRate(
    { effectProcessor.processAll() },
    0, 100, TimeUnit.MILLISECONDS
)

// Or using Kotlin coroutines
launch {
    while (isActive) {
        effectProcessor.processAll()
        delay(100.milliseconds)
    }
}
```

**Pros**: Simple, no additional infrastructure, works with any MySQL deployment  
**Cons**: Latency up to poll interval, wasted queries when outbox is empty, multiple instances may compete

**Tuning tips**:
- Use exponential backoff when outbox is empty
- Add jitter to avoid thundering herd across instances
- Use `SELECT ... FOR UPDATE SKIP LOCKED` to allow parallel processing

### 2. Application-Level Triggering

Trigger processing immediately after a transition succeeds:

```kotlin
class OrderService(
    private val stateMachine: StateMachine<...>,
    private val effectProcessor: EffectProcessor<...>
) {
    fun confirmOrder(order: Order, paymentId: String): Result<Order> {
        return stateMachine.transition(order, ConfirmOrder(paymentId))
            .onSuccess { 
                // Fire-and-forget processing in background
                scope.launch { effectProcessor.processAll() }
            }
    }
}
```

**Pros**: Low latency for the triggering request, no polling overhead  
**Cons**: Effects from other instances/requests not processed, still need polling as fallback

### 3. Database Change Data Capture (CDC)

Use MySQL binlog streaming via Debezium, Maxwell, or similar:

```
MySQL binlog → Debezium → Kafka → Consumer → EffectProcessor
```

```kotlin
// Kafka consumer example
@KafkaListener(topics = ["outbox.events"])
fun onOutboxEvent(event: OutboxEvent) {
    effectProcessor.processOne(event.messageId)
}
```

**Pros**: Near-realtime, scalable, decoupled  
**Cons**: Additional infrastructure (Kafka, Debezium), more operational complexity

### 4. Cloud-Native Event Triggers

Some cloud MySQL offerings support event triggers:

**AWS Aurora with Lambda:**
```
Aurora → Event Notification → SNS → Lambda → EffectProcessor
```

**Google Cloud SQL with Cloud Functions:**
```
Cloud SQL → Pub/Sub (via CDC) → Cloud Function → EffectProcessor
```

**Pros**: Serverless, auto-scaling, managed infrastructure  
**Cons**: Vendor lock-in, cold start latency, requires cloud-specific setup

### 5. Hybrid Approach (Recommended)

Combine immediate triggering with background polling:

```kotlin
class HybridEffectTrigger(
    private val effectProcessor: EffectProcessor<...>,
    private val scope: CoroutineScope
) {
    private val hasWork = AtomicBoolean(false)
    
    init {
        // Background poller as safety net
        scope.launch {
            while (isActive) {
                if (hasWork.getAndSet(false) || Random.nextFloat() < 0.1f) {
                    effectProcessor.processAll()
                }
                delay(1.seconds)
            }
        }
    }
    
    // Called after successful transitions
    fun triggerProcessing() {
        hasWork.set(true)
        scope.launch { effectProcessor.processAll() }
    }
}
```

**Pros**: Low latency for normal operations, resilient to missed triggers  
**Cons**: Slightly more complex than pure polling

### Scaling Considerations

When running multiple application instances:

1. **Outbox partitioning**: Assign each instance a partition of the outbox (e.g., by `value_id % instance_count`)
2. **Distributed locking**: Use `SELECT ... FOR UPDATE SKIP LOCKED` to allow concurrent processing
3. **Leader election**: Only one instance polls, others are standby (use Zookeeper, etcd, or database-based locking)

```kotlin
// Example: SKIP LOCKED for concurrent processing
@Query("""
    SELECT * FROM outbox 
    WHERE processed_at IS NULL 
    ORDER BY created_at 
    LIMIT 10 
    FOR UPDATE SKIP LOCKED
""")
fun claimPendingMessages(): List<OutboxMessage>
```

---

## Migration Guide

### Step 1: Define Your Effects

Convert your side effects into a sealed class:

```kotlin
// Before (v1): Effects scattered in transitions
class SendEmail : OrderTransition(...) {
    override fun effect(value: Order): Result<Order> {
        emailService.send(...)
        return Result.success(value)
    }
}

// After (v2): Centralized effect types
sealed class OrderEffect : Effect {
    data class SendEmail(val orderId: String, val email: String) : OrderEffect()
    data class ChargePayment(val orderId: String, val amount: Money) : OrderEffect()
}
```

### Step 2: Simplify Your States

Remove the extra type parameters:

```kotlin
// Before (v1)
sealed class OrderState(
    transitionsFn: () -> Set<OrderState>,
    invariants: List<Invariant<String, Order, OrderState>> = emptyList()
) : State<String, Order, OrderState>(transitionsFn, invariants)

object Pending : OrderState({ setOf(Confirmed, Cancelled) })

// After (v2)
sealed class OrderState : State<OrderState>() {
    data object Pending : OrderState() {
        override fun transitions() = setOf(Confirmed, Cancelled)
    }
}
```

### Step 3: Convert Transitions to use decide()

Replace `effect()` with `decide()`:

```kotlin
// Before (v1)
class ConfirmOrder : OrderTransition(from = Pending, to = Confirmed) {
    override fun effect(value: Order): Result<Order> {
        emailService.send(value.email, "Confirmed!")
        return Result.success(value)
    }
}

// After (v2)
class ConfirmOrder : OrderTransition(from = Pending, to = Confirmed) {
    override fun decide(value: Order): Decision<OrderState, OrderEffect> =
        Decision.accept(
            state = Confirmed,
            effects = listOf(OrderEffect.SendEmail(value.id, value.email))
        )
}
```

### Step 4: Implement Repository and Outbox

Create a repository that saves state and outbox messages atomically:

```kotlin
class JooqOrderRepository(private val dsl: DSLContext) : Repository<String, Order, OrderState, OrderEffect> {
    override fun saveWithOutbox(
        value: Order,
        outboxMessages: List<OutboxMessage<String, OrderEffect>>
    ): Result<Order> = runCatching {
        dsl.transactionResult { config ->
            val txDsl = DSL.using(config)
            upsertOrder(txDsl, value)
            outboxMessages.forEach { insertOutboxMessage(txDsl, it) }
            value
        }
    }
}
```

### Step 5: Implement EffectHandler

Create a handler that executes effects:

```kotlin
class OrderEffectHandler(
    private val emailService: EmailService,
    private val paymentService: PaymentService
) : EffectHandler<String, Order, OrderState, OrderEffect> {

    override fun handle(valueId: String, effect: OrderEffect): Result<EffectOutcome<...>> =
        when (effect) {
            is OrderEffect.SendEmail -> {
                emailService.send(effect.email, "Order ${valueId} confirmed")
                Result.success(EffectOutcome.Completed)
            }
            is OrderEffect.ChargePayment -> {
                val txId = paymentService.charge(effect.amount)
                Result.success(EffectOutcome.TransitionProduced(
                    valueId,
                    PaymentReceived(txId)
                ))
            }
        }
}
```

### Step 6: Replace Transitioner with StateMachine

```kotlin
// Before (v1)
val transitioner = OrderTransitioner(database)
val result = transitioner.transition(order, ConfirmOrder())

// After (v2)
val stateMachine = StateMachine(repository)
val result = stateMachine.transition(order, ConfirmOrder())

// Process effects separately
effectProcessor.processAll()
```

### Step 7: Set Up Background Processing

Run the effect processor periodically or on database notifications:

```kotlin
// Simple polling approach
while (true) {
    effectProcessor.processAll()
    delay(100.milliseconds)
}

// Or use database LISTEN/NOTIFY, CDC, etc.
```

---

## Testing in v2

v2 makes testing dramatically easier because decision logic is pure:

```kotlin
@Test
fun `confirm order produces email effect`() {
    val order = Order(id = "123", state = Pending, email = "test@example.com")
    val transition = ConfirmOrder()
    
    val decision = transition.decide(order)
    
    decision.shouldBeInstanceOf<Decision.Accept<*, *>>()
    decision.state shouldBe Confirmed
    decision.effects shouldContain OrderEffect.SendEmail("123", "test@example.com")
}

@Test
fun `reject order with zero total`() {
    val order = Order(id = "123", state = Pending, total = Money.ZERO)
    val transition = ConfirmOrder()
    
    val decision = transition.decide(order)
    
    decision.shouldBeInstanceOf<Decision.Reject<*, *>>()
    decision.reason shouldContain "total must be positive"
}
```

No mocking, no database, no transitioner setup—just pure function testing.

---

## When to Use v2

**Use v2 when:**
- You need reliable effect execution (emails, webhooks, external APIs)
- You have multi-step workflows that span async operations
- You want to test business logic without infrastructure
- You're building distributed systems where failures are common
- You need audit trails of state changes and effects

**v1 may still be suitable when:**
- Effects are truly synchronous and local (in-memory state only)
- You need the simplest possible setup
- You're prototyping and reliability isn't critical yet

---

## Example: Document Upload Workflow

See the [example-v2](../example-v2) module for a complete implementation demonstrating:

- MySQL-backed persistence with jOOQ
- Transactional outbox pattern
- Async virus scanning on a separate thread
- Multi-step workflow with automatic effect chaining
- AwaitableStateMachine for sync-style API over async workflow

```kotlin
// The workflow: Created → Uploading → AwaitingScan → Scanning → Accepted/Quarantined
val result = awaitableStateMachine.transitionAndAwait(
    value = document,
    transition = StartUpload(fileContent),
    timeout = 30.seconds
)
// Returns when document reaches Accepted, Quarantined, or Failed
```
